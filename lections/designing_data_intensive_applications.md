## Часть 1 Основы информационных система

### Высоконагруженные данными приложения - data intensive applications - DIA

### Высоконагруженные вычисления - compute intensive

### Надежность - reliability

### Масштабируемость - scalability

### Удобство сопровождения - maintainability

### Разработка состоит:

- **Надежность - reliability**
    - устойчивость к аппаратным и программным сбоям, человеческим факторам
    - способность выдержать ошибочные действия пользователя
    - предотвращать не санкционный доступ или неправильную эксплуатацию
    - работать нормально в случае проблем
- **Масштабируемость - scalability**
    - показатели нагрузки и производительности, время ожидания, процент или пропускная способность
- **Удобство сопровождения - maintainability**
    - удобство эксплуатации, простота и возможность развития

### Сбой vs Отказ

- сбой - fault
    - отклонение одного из компонентов системы от рабочих характеристик
- отказ - failure
    - система в целом прекращает предоставление сервиса
- > Предотвратить переход сбоев в отказ
- необходимо генерить сбои, чтобы добиться устойчивости - Хаос инжиниринг

#### Аппаратные сбои

- среднее время на отказ (mean time to failure, MTTF)
    - винчестер работает от 10 до 50 лет
        - если в кластере 10 000 винчестеров, примерно 1 отказ в день
        - решение - RAID массивы, дублирование и т.д.
- применять методы устойчивости чем избыточность аппаратного обеспечения

#### Программные сбои

- чтобы избежать, полезно:
    - всесторонние тесты
    - изоляция процессов
    - мониторинг
    - анализ поведения системы при эксплуатации
    - самопроверка внутри сервиса

#### Человеческий фактор

- ошибки в конфигурации операторами
- предоставить эксплуатации (операторам) песочницу для изучения и экспериментирования с системой
- тестирование на всех уровнях, автоматизированное тестирование с пограничными случаями
- обеспечить быстрое восстановление после выявления ошибок, откат конфигурации
- настроить явный мониторинг, метрики (телеметрия), что позволит определить на ранней стадии нарушения

### Нагрузка

- нагрузку можно описать параметрами нагрузки, например:
    - количество запросов в секунду
    - отношение операция чтения к записи в БД
    - количество активных клиентов в чате
- бывает, что чтение чаше записи, тогда при таком лучше сразу писать кеш при операции записи, чтобы при чтении не
  производить вычисления

### Описание Производительности

- как измениться производительность системы если увеличить нагрузку, а ресурсы системы не менять (CPU, RAM)
- насколько нужно увеличить ресурсы при увеличении нагрузки, чтобы производительность не уменьшалась

### Время ожидания vs Время отклика

- **время ожидания - latency**
    - длительность ожидания запроса обработки, время на протяжении которого ожидает обслуживания
- **время отклика - response time**
    - то, что видит клиент, помимо обработки запроса включает задержки сети, сообщений в очереди
    - Параметр времени отклика:
        - арифметическое среднее (не самое лучшее), типа среднее время запросов 400мс, хотя при этом может быть 200мс и
          5 секунд(что не допустимо)
        - процентили - среднее по разным показателям, например:
            - считаем в процентах запросы до 200мс и так далее, и выясняем соотношение этих групп, каких больше
            - 99% запросов менее 200мс, 1% больше секунды - на самом деле, 1% может быть самыми ценными запросами

### Принципы проектирования

- удобство эксплуатации - облегчение поддержки
- простота - облегчает понимание системы новыми инженерами
- возможность развития - упрощает внесение изменений в будущем, адаптация
    - расширяемость - extensibility
    - модифицируемость - modifiability
    - пластичность - plasticity

#### Удобство эксплуатации

- максимально автоматизировать, чтобы персонал отвечал только за:
    - мониторинг состояния системы и восстановления
    - выяснение причин проблем, отказов
    - поддержка актуального ПО
    - отслеживание влияния систем друг на друга
    - введение в эксплуатацию
    - перенос с одной системы на другую
    - поддержка безопасности

#### Простота

- для исключения побочной сложности - лучше инструкция абстракций. Хорошая абстракция позволяет скрыть большую часть
  реализации за фасадом
- многократное применение одного и того же хорошо

#### Agile

- паттерн рабочего процесса, обеспечивающий инфраструктуру адаптации к изменениям

#### TDD

- разработка через тестирование

#### Evolvability - возможность развития (адаптация на уровне информационных систем)

### Требования приложений:

- функциональные: хранение, извлечение, поиск, обработка
- нефункциональные: безопасность, надежность, соответствие нормативным документам, масштабируемость, удобство
  сопровождения

## Часть2 Модели данных и языки запросов

#### RDBMS

- relation database management system - реляционные системы управления базами данных

#### Система управления - Information Management System - IMS

### Иерархические модели:

- реляционная SQL
- сетевая модель "канула в лету"

### SQL

- декларативный язык запросов
- выполнить определенные операции в заданном порядке

### MapReduce

- модель программирования для обработки больших объектов данных блоками на множестве машин
- ни декларативный не императивный
- состоит из map и reduce - должны быть чистыми (pure), используются только передаваемые данные
- основан на JavaScript функции

### Графоподобные модели данных

- вершины - vertices, узлы - node, или сущности - entity, состоит:
    - состоит из идентификатора, множества исходящих и входящих ребер
- ребра - edge, связи - relationship, или дуги - arc, состоит:
    - уникальный идентификатор
    - вершина с которой начинается (начальная)
    - вершина которой оно заканчивается (конечная)

### Графовое хранилище:

- из 2 реляционных таблиц:
    - вершины
    - ребра

### Аспекты графового хранилища:

- любая вершина может быть соединена ребром с любой другой вершиной
- для любой вершины можно найти входящие, исходящие ребра, выполнить обход графа, найти путь по цепочке вершин
  в прямом и обратном направлениях
- в одном графе, задействуя разные виды связей можно хранить разные виды информации

#### Cypher

- декларативный язык запросов для графовых БД

### Тройные кортеж

- [ субъект, предикат, объект] - (lucy, age, 33)
- субъект
    - эквивалентен вершине графа
- объект
    - представляет одну из 2 вещей:
        - Значения простого типа данных (строка, число). При этом предикат и объект эквивалентны ключу и значению
          свойства
          вершины объекта. Вершина Lucy со свойствами {age: 33}
        - Другую вершину графа. Предикат здесь ребро графа, субъект начальная вершина, объект конечная вершина
            - Lucy, marriedTo, alain

#### SPARQL

- язык запросов для хранилищ тройных кортежей, использующих модель данных RDF (protocol and RDF Query Language)

### Фундамент datalog

- модель данных аналогична модели хранилищ тройных кортежей
    - пример, name (usa, "United States").type(usa, country)
    - правило работает если системе удается найти соответствие для всех предикатов справа от оператора
    - запрос, recursive(location, Name) :- name (Location, Name)
- используется в Datomic
- синтаксис S-выражений
- похож на Prolog
- слова с большой буквы это переменные

### Нереляционные. NoSQL

- отсутствие обязательной схемы для хранения данных
    - Документированные - данные в виде отдельных документов, связи между ни редкие
    - Графовые (MongoDB) - предназначены для сценариев, в которых данные могут быть связаны

## Часть 3 Подсистемы хранения и извлечения данных

```
  Если вы поддреживаете в вещах порядок, значит вы просто слишком ленивы, чтобы их искать
```

У БД есть две задачи:
- сохранность при получении
- предоставление данных

Простой пример
- вставка - db-set 12345 {"name": "london"}
- вставка - db-set 42 {"name": "Tula"}
- получение - db-get 42 //{"name": "Tula"}
```
 #!bin/bash
 db-set(){
    echo "$1,$2" >> database
 }
 
 db-get(){
    grep "^$1", database | sed-e "s|^$1,||" | tail -n 1
 }
 
 // вставить можно хоть JSON
```
- в данном поиск - O(n), поэтому необходим индекс
- текстовый файл, где данные (ключ, значение) разделены запятой
- здесь поиск ключа с конца и до первого вхождения
- данные добавляются в конец, это эффективно (у многих БД так)
- этот файл и есть журнал последовательность записей, предназначенных для добавления в конец данных
  - данные могут быть двоичные либо другие

### Индекс
- дополнительная структура, производная от основных данных
- идея в дополнительном хранении определенных метаданных как указатели, помогающие найти данные
- добавление индекса дорого
- по умолчанию многие БД не индексируют, поэтому делаем руками!!

- > Индексы ускоряют чтение, замедляют запись

### Хеш индекса
- для простого примера, хранить Хеш карту, и класть/забирать данные всегда из одного места

#### Решение исчерпания места на диске
- разбить журнал на сегменты определённого размера, закрывая файл при достижении определенного размера, и записывать в новый файл
- после можно выполнить **Уплотнение** (compaction)
  - отбрасывание дублирующих ключей (оставлять только последние записи)
  - это лучше делать в отдельном потоке
  - можно слить несколько файлов и уплотнить

#### Формат файлов
- CSV - не лучшее решение для журнала
- Двоичный наиболее подходящее

#### Удаление записей
- на записи ставится отметка об удалении
- при слиянии эта запись не засчитывается

#### Восстановление после сбоя
- после перезапуска Хеш карта в оперативной памяти теряется, но можно прочитать записи и по ключам восстановить Хеш карты
- либо сохранить копии Хеш карт на диске

#### Недописанные записи
- записывать контрольные суммы, при восстановлении можно обнаружить и игнорировать поврежденные части журнала

#### Управление конкурентным состоянием
- запись строго в одном потоке
- чтение параллельно

### SS-таблица и LSM-деревья
- журналированное дерево слияния - log structured merge
- sorted string table - данные отсортированны по ключу
- каждый ключ встречается один раз в объединенном сегменте
- метод слияния больших журналов выполняется просто и эффективно, похож на сортировку слиянием
- не нужно хранить индекс ключей, но храним индекс смещения (разраженный)
- для поддержания сортировки данных при записи используются деревья (красно-черные VL-дерево)
- храним дерево в оперативной памяти, если становится большим пишем на диск в виде SS-таблицы
  - одна большая проблема, если происходит сбой, все данные из MemTable - в оперативной памяти теряются
  - для этого параллельно можно использовать обычный журнал и писать данные в него, для восстановления MemTable

#### Создание LSM дерева из SS-таблиц
- описывается алгоритм (выше который) используется в Level DN, Rocks DB
- одна из проблем отсутствие ключа, придется прочитать весь MemTable, для этого используется Фильтр-Блума, позволяющий установить встречающиеся ключи в БД
- используется по уровневое уплотнение в соответствии с размером или по слоям

#### B-деревья
- индексная структура, используется до сих опр в реляционных и нереляционных БД
- как SS-таблицы хранят ключ-значение в отсортированных по ключу
- БД разбивается на блоки или страницы фиксированного размера (~4кб)
- все страницы имеют адрес и могут ссылаться на другие аналогично указателям
- эти ссылки используются для создания дерева страниц
- одна из страниц корень
- количество ссылок на дочерние страницы на одной странице B-дерева - это коэффициент ветвления (branching factor)
  - алгоритм сбалансированного дерева, обычная глубина 3-4 уровня

#### Надежность B-дерева
- для отказоустойчивости включают дополнительную структуру данных
  - журнал упреждающей записи (write head WAL), он же журнал повтора (redo log)
  - в него добавляются только все модификации B-дерева до того как будет применимо к страницам дерева

#### Усовершенствования B-дерева
- использовать сохраненный ключ
- использовать схему копирования при записи, измененная странице записывается в другое место с созданием новых версий родительских страниц

- > LSM быстрее при записи
  > В-деревья быстрее при чтении
  > НО!! все зависит от нюансов конкретной системы
  >

#### Вторичный индекс 
- secondary index
- можно создать несколько

#### Сцепленный индекс
- concatenated index
- объединяет несколько полей (один столбец к другому)
- типа лоя поиска фамилия + имя
- но бесполезен для поиска всех полей

#### Нечеткий индекс
- поиск даже с учетом опечатки (вхождение с одним неправильным символом)

### БД в оперативной памяти
- in memory datatable
- при этом используется Rav на аккумуляторе?!
- периодическая запись на диск, либо репликация на другие машины
- при запуске загружается состояние с диска или других машин
- > Пример, БД Volt DB, MemSql, Oracle TimerTen

### Транзакции
- обработка транзакций в реальном времени (online transaction processing OLTP)
- паттерн - приложение с помощью индекса ищет небольшое количество данных по ключу. На основе вводимых данных сопоставляются или обновляются данные
- либо наоборот - online analytical processing (OLAP)
  - Аналитическая обработка данных в реальном времени, где огромное количество просматриваемых данных и вычисляя сводные данные

#### Склад данных
- data warehouse - отдельные БД для аналитиков, копия данных только для чтения
- процесс помещения данных в склад "извлечение" - преобразование загрузка (extract transform ETL)
- чаще реляционные

#### Схема звезда
- star schema - моделирование с помощью измерений (dimensional modeling)
- одна таблица фактов, а остальные по разных таблицам
- используется таблица фактов (отдельное событие)
- ссылается на таблицу измерений

#### Схема снежинка 
- похожа на "звезду", только измерения разбиваются на подизмерения
- в складе данных может быть до +100 столбцов
- Select* - редко, обычно 4-5 столбцов, но большим количеством строк

#### Столбцовое хранилище
- нужно хранить рядом все значения не из одной строки, а из одного столбца
- так можно использовать сжатие-кодирование с помощью битовой карты - bitmap encoding

#### Сортировка в столбцевом хранилище
- можно сортировать по частому запросу (например, по дате)
- сортировка по разным ключам и хранение в таком виде (разные сортировки) на разных репликационных машинах (т.к. копии все равно делаются)

#### Запись столбцевом хранилище
- вначале обработка в оперативной памяти (вставка и поддержка сортировки) только потом запись на диск

#### Материализованное представление
- materialized view - запросы с функцией агрегирования (count, SUM) и записывать в кеш

## Часть 2 Кодирование и эволюция
- Возможность развития - evolvability
- Плавающее обновление - rolling upgrade (поэтапное развертывание)
  - новая версия разворачивается на нескольких узлах и проверяется, работает ли она без проблем
  - обратная совместимость - более новый код способен читать данные, записанные старой версией
  - прямая совместимость - старый код способен читать данные, записанные новой версией

### Кодирование
- преобразование из представления в памяти в последовательность байтов или маршалинг (marshaling) или сериализация (serialization)
- обратная операция - декодирование (decoding), парсинг (parsing), десериализация, демаршалинг

#### Библиотеки двоичного кодирования
- Apache Thrift - Facebook (Binary protocol, Compact Protocol)
- Protocol Buffers - Google

- > Compact protocol, Protocol Buffer - кодировка чисел разбивается на 2 байта - 1337  1|111001 0|00110100 -> 9 Oa -> 1337

#### Avro
- двоичный формат, содержит два языка описания схем
  - Avro IDL - для редактирования людьми
  - основанный на JSON - для считывания ПК
- схема для чтения и записи необязательно должны совпадать, достаточно быть совместимы
- при больших файлах, схема вставляется в начало файла (либо версию схемы), а схему отдельно в БД - схема на весь документ

#### Поток данных через БД
- время жизни данных превышает время жизни кода

### REST & API
- клиентское приложение JS в браузере может задействовать XMLHttpRequest - чтобы стать Http-клиентом - технология AJAX
- Сервисно-ориентированная архитектура (service oriented architecture SOA)
  - когда сервер есть клиент для других
  - в последнее время это называется микросервисная архитектура

### Веб сервисы
- если в качестве базового протокола HTTP
- REST
  - !! НЕ протокол, а подход к проектированию, основанный на принципах Http (RestFull)
  - просто указать версию API в заголовках Accept
- SOAP
  - основан на XML
  - API SOAP - веб-сервис описанные языком описания веб-сервисов WSDL - web services description language
  - код генерируется с помощью WSDL запроса

### RPC
- remote procedure call - удаленный вызов процедур
- идея, что запрос к удаленному сетевому сервису выглядит как вызов функции или метода вне зависимости от расположения
- МИНУСЫ
  - запрос может потеряться в сети (сбой)
  - учитывать, что запрос прошел, но на самом деле потерялся
  - учесть повторный вызов одной и той же операции (механизм дедупликация - идемпотентности)
  - параметры нельзя передать как ссылки (указатели) на объект (необходимо кодировать)
  - клиент и сервис могут быть на разных языках, что может привести к проблемам, например, числа с плавающей точкой 2^53 в JS
- Фреймворки
  - Thrift, Avro - используют Protocol Buffers
  - Finagle, Rest.li - используют фьючерсы (futures) промисы
- gRPC
  - поддержка потока данных (stream)

### Система асинхронной передачи сообщений
- запрос от клиента называется сообщением (message)
- сообщения проходят не напрямую, а через посредника - брокера сообщений (message broker) или очередь сообщений (message queue)
  или промежуточное ПО, ориентированным на обработку сообщений (message - oriented middleware)

### Брокеры сообщений
- TIBCO, WebSphere, webMethods (старое)
- RabbitMQ,  ActiveMQ, Apache Kafka

### ИИспользование брокера сообщений
- один процесс отправления сообщений для очереди или темы/дискуссии (topic), а брокер обеспечивает доставку сообщений потребителям (consumers) или подписчикам (subscribers)
- в одной дискуссии может быть много инициализаторов (producers) и много потребителей
- можно использовать любой формат кодирования

#### Акторная модель (actor model)
- модель программирования для создания конкурентного доступа в пределах одного процесса
- каждый актор соответствует одному клиенту ли сущности (может быть свое локальное состояние)
- один актор обрабатывает одно сообщение
- допускается потеря сообщения в пределах одного процесса
- фреймворки
  - Akka (Java)
  - Orleans
  - Erlang OTP - можно менять схемы записи

## Часть 3 Распределенные данные
- > В 1 части вопросы системы данных, актуальные при хранении данных на отдельных машинах
  > В 2 части извлечение и хранение на нескольких машинах

### Масштабирование
- если объем данных, нагрузка по чтению и записи перерастает возможности одной машины, то можно распределить на несколько машин
- вертикальная
  - vertical scaling
  - увеличение мощности одной машины
  - использование как вариант архитектуры с раздельными дисковыми накопителями
    -  несколько машин, но данные на одном массиве
- горизонтальная
  - horizontal scaling
  - архитектура без разделения ресурсов (shared nothing architectures)
  - отдельная машина - это узел (node), свой CPU, диск, память
  - согласование на уровне ПО с помощью сети
  - можно рапрделеиять географически, для своего региона
  - требуется наибольшая осторожность при разработке

### Способы распределения данных по нескольким узлам
- Репликация - копии одних и тех же данных, хранятся на нескольких узлах
  - в случае отказа, часть узлов данных можно вытащить из других
  - горизонтальная масштабируемость для чтения
- Секционирование
  - разбиение данных на подмножества (секции partition) - разным узлам можно подставить в соответствии различные секции - шардинг

#### Алгоритмы репликации
- с одним ведущим узлом (single leader)
- с несколькими ведущими узлами (multi leader)
- без ведущего узла (leaderless)

- > Узлы, в которых хранятся копии БД, называются Репликами

##### Проблемы репликации
- гарантия одних и тех данных во всех репликах

#### Решение проблемы гарантии:
- репликация с ведущим узлом
  - одни ведущий, другие ведомые (followers)
  - когда ведущий записывает, он отправляет информацию всем followers в качестве части журнала репликации или потока изменений
```
Запрос (чтение/запись) -> Реплика ведущего узла -> Изменение данных -> реплика ведомых узлов 
                                                                    -> реплика ведомых  узлов <- только на чтение
```
  - Запросы на запись только в ведущем узле (PostgreSQL, muSql, Espresso, RabbitMQ, Kafka)

#### Синхронизированные и асинхронные реплики
- Синхронные
  - ведущий узел ждет подтверждения изменений от ведомых, после отвечает пользователю
  - копии гарантированно актуальны и согласованы, но если ведомый недоступен, то запись прервется
  - решение в случае сбоя узла, перевести его в асинхронный режим (полу-синхронная конфигурация - semi - synchronous)
- Асинхронные
  - ведущий узел Не ждет подтверждения от ведомых
  - при сбое ведущего - сохранность данных не гарантируется

#### Создание нового ведомого узла
- Проблема
  - при копировании БД, записи идут постоянно. Как обеспечить копирование без блокировки основной БД
- Решение
  - создать согласованный снимок состояния БД на определенный момент времени без блокировки БД в основной БД
    - в многих БД есть резервная копирование - можно использовать это
  - скопировать снимок состояния на ведомый узел
  - ведомый узел подключится к ведущему и запрашивает все изменения с момента снимка, с определенной позиции журнала снимка состояния
    регистрация номера транзакции в журнале - log sequence number
  - когда ведомый завершит обработку изменений, такое состояние называется Наверстывание упущенного

#### Перебои в обслуживании
- цель, чтобы система продолжал работать при отказе отдельного узла
- отказ Ведомого
  - у него есть журнал последних транзакций, после перезагрузке нагоняет упущенное от ведущего
- отказ Ведущего
  - необходимо повысить в звании один из ведомых узлов до ведущего
  - настроить клиентов на новый
  - настроить ведомые на нового ведущего
  - этот Процесс называется "Восстановление после отказа"
    - вручную или автоматизированно
      - установить отказ ведущего узла (питание, сеть)
      - выбрать нового ведущего (оптимально самая свежая реплика)
      - настроить систему на новый ведущий узел
  - НО!! есть опасности
    - старый ведущий может проснуться и так же быть ведущим (необходимо настроить механизм отключения если 2 ведущих)
    - проблема нереплицированных последних данных

#### Операторная репликация
- если с ведущего отсылать запросы SQL на ведомые, чтобы те делали те же самые операции, то будут проблемы например с датой

#### Перенос журнала упреждающей записи (WAL)
- записывать журнал и передавать ведомым, а те создают точные копии структур данных

#### Логическая (построчная) журнальная репликация
- логический журнал - разные форматы журнала для репликации и подсистем хранения

#### Триггерная репликация
- репликация подмножества данных либо БД одного и того же типа в БД другого типа
- репликация на уровне приложения
- Триггеры позволяют регистрировать пользовательский код, запускаемый при возникновении в БД события изменения данных
  - DataBus Oracle, Bucardo Postgres
- больше расходов и возможности ошибок
  
#### Проблемы задержки репликации
- синхронная - сбой если 1 узел отвалился
- асинхронная - можно получить устаревшие данные от ведущего
  - необходимо дождаться согласованности между узлами
  - конечная согласованность (eventual consistency) - неоднозначное время - от миллисекунд до минут
- Варианты решения
  - монотонное чтение - один пользователь может читать только с одной репликации
    - если идет запись, то и запрос чтения с той репликации

#### Репликация с несколькими ведущими узлами
- multi leader replication 
- чаще используется когда несколько ЦОД, и в каждом по 1-му ведущему узлу
  - BDR Postgres, Tungsten Replicator MySql, Couch DB
- необходимо решать конфликты записи (одна и та же запись на разных БД)

#### Совместное редактирование
- realtime collaborative editing
- не решает задачи репликации БД, но имеет много общего
- используется блокировка, чтобы было по очереди редактирование
- обычно блокировка одно нажатие клавиши
- и тут же репликация всем (эквивалент один ведущий узел)
- конфликт можно решить по времени, кто последний тот и прав
  - лучше предотвращать - один ведущий узел или синхронная операция
  - например, запись может быть с разных машин, а при одновременной записи перенаправлять на один узел и использовать блокировку

#### Топологии репликации с несколькими ведущими узлами
- каждый с каждым (наиболее подходящий)
- звезда - один узел корневой и он всем передает (можно обобщенное дерево)
- кольцо - каждый узел получает и передает ровно от одного узла
- Проблема кольца и звезды
  - при отказе одного оборвется поток сообщений
- Проблема каждый с каждым
  - ссылки могут быть быстрее других
  - одни сообщения реплик обгоняют других (состояние гонки)
    - можно получить ответ, но вопрос придет позже, типа ответ из будущего

#### Репликации без ведущего
- Amazon использует систему Dynamo-> Dynamo DB (а она уже с ведущим узлом)
  - отсюда Dynamo подобные БД, Dynamo Style database
- при записи информация добавляется сразу всем репликам
- если одна не дает, но 2 и более дадут ответ, клиент получит подтверждение
- при чтении запрос идет параллельно, чтобы не получить старые версии, проверяется версия записи
- параллельно идет процесс - противодействие энтропии
  - ANTI ENTROPY PROCESS
    - постоянный поиск различия между репликами и копирует не достающее
- если 2 из 3 не запишут, тогда активные данные выбираются по кворуму
  - подтверждение w узлами
  - опросить минимум r узлов
  - n всего узлов
    - w + r > n, удовлетворение условного есть чтение, запись по кворуму
    - показатель, сколько система может позволить себе недоступных узлов
    - чтение и запись проверяется по значению кворума, то есть если w=3 из n=5, r=3, то операция успешна
      - если меньше будет ошибка операции

#### Отбраковка конкурентных операций записи
- lost-write
  - выигрывает последний один из вариантов
- wins
  - добавлять метку даты -> выбирается свежая, остальные отбраковываются
- lww
  - не лучший вариант если важно не терять данные

#### Векторы версий
- помимо номера версии данных, реплике присваивается версия реплики при выполнении операции записи
- набор векторов версий - называется вектором
- самая интересная разновидность
  - конечный вектор версии - dotted version vector
- при ответе отдается вектор и номер версии данных

-> Векторные версии иногда показывают векторные часы (vector clock), хотя это не одно и тоже

### Секционирование - partitioning
- умышленное разбиение большого набора данных
- основная цель масштабируемость
  - разные секции разместить в различныых узлах кластера
    - по многим жестким дискам
- Teradata, Tandom NonStop SQL
- копий секций как и реплики хранят на разных узлах
- цель секционирования
  - равномерно распределять по узлам данные и загрузку запросов
  - если части секции неравномерные -> асимметричные
    - наличие асимметрии снижает эффективность (skewed)
    - такая ситуация называется "горячей точкой" - "hot spot"
- один из методов секционирования
- назначить непрерывный диапазон значений ключа (от мин до макс) на каждую секцию, подобно бумажной энциклопедии
  - могут быть разной величины, например
    - от Антона до Бориса (где имя ключ), от Бориса до Вячеслав
  - может использоваться хеш ключа
  - в Java Object.hasCode() - могут возвращать различные значения ключа в разных процессах
  - !! при таком смежные ключи будут разбросаны по разным секциям
  - если ключ горячий, то простейшее решение
    - добавление в начало или конец случайного числа, чтобы разбить по разным секциям
      - только для не большого количества ключей, ио это затратно
      
#### Вторичные индексы
- поиск вхождений - "найти все действия пользователя 123"
- Sole, Elasticsearch
- 2 подхода
  - секционирование по документам - document-based partitioning
  - секционирование по термам - term-based partitioning

-> Перебалансировка - rebalancing - процесс перемещения нагрузки с одного узла в кластер на другой

#### Методики перебалансировки
- ПЛОХО
  - хеширование по модулю
    - суть, плохо для хеша mod N
    - частые перемещения ключей из-за роста N узлов
- Фиксированное количество секций
  - задать сразу фиксированное количество (1000) и распределять по узлам (10) 100 на узел
    - при добавлении узла заимствует по несколько секций, пока секции не станут равномерными
- Динамическое секционирование
  - при неправильном задании количества секций (фиксированно), можно получить все данные в одной секции
  - HBase, RethinkDB
  - когда размер секции перерастает данные, он разбивает на 2 секции
  - и наоборот, если значительное количество данных удаляется, секцию сливают с соседней (аналог в B-деревьях)
  - получается, в самом начале данных нет, создаем одну секцию, 
    - при таком другие узлы простаивают
    - для этого делают предварительное разбиение (pre-splitting)

#### Маршрутизация запросов
- как клиент знает к какому узлу нужно подключится
  - обнаружение сервисов (service-discovery)

##### Решение проблемы маршрутизации запросов
- разрешить клиенту обращаться к любому узлу
  - если ответ в секции на узле, тогда ответит, если нет перенаправит на нужный узел
- направлять все запросы клиента сначала маршрутизаторному звену, а он перенаправляет на нужный.
  - Само звено не обрабатывает запросы
- требовать, чтобы клиенты учитывать секционирование и распределение по узлам

-> Во всех случаях проблема - откуда отвечающий за маршрутизацию компонент знает об изменениях в распределении секций