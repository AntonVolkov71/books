## Глава 1 Платформа Node.js

- 'use strict' строгий режим
  - невозможно использовать необъявленные переменные
  - невозможно удалить переменные функции, аргументы

- стрелочные функции - для использования родительского this
  - setTimeout(function(){},0) - использует свой this
    - вместо setTimeout(function(){},0).bind(this) - setTimeout(()=>{},0)

- Map, Set 
  - хешированные коллекции, где ключом может быть что угодно (функция, объект и т.д.)
  - перебор for..of, Map -> [key, value] и извлекаются в том же порядке как были сохранены

- WeakMap, WeakSet
  - отсутствует перебор
  - сборщик мусора, если ключ был объект и его удалили, то удаляет из коллекции

### Асинхронная природа Node.js
- серверы, созданные с использованием этой среды, не ожидают завершения операций ввода-вывода, прежде чем продолжить выполнение других задач.
- подразумевает наличие неблокирующего ввода-вывода, что позволяет в процессе ожидания ответа на запрос, например, к базе данных, выполнять другие операции и обрабатывать другие запросы.

### Reactor
- кратко, приложение в некоторый момент желает обратиться к ресурсу (без блокировки) и передает обработчика,
 который должен быть вызван некогда в будущем, после завершения операции

- > Приложение Node.js завершиться автоматически, когда в демультиплексоре событий не останется отложенных операций и событий в очереди
- низкоуровневая С-библиотека libuv обеспечивает программный интерфейс для создания циклов событий, управления очередью событий,
выполнения асинхронных операций ввода/вывода и организации очереди заданий разных типов

- **Основные блоки**
  - набор привязок для libuv
  - движок V-8
  - node-core - ядро библиотеки JavaScript

## Глава 2 Основные шаблоны
- Синхронное - последовательные вычисления, операция блокируется до её завершения
- Асинхронное - операция переводится в фоновой режим, сразу выполняется следующая

### Шаблон Callback
- **обратные вызовы (Callback)** - функции, вызываемые для передачи результата операции, вместо return (return синхронный)

#### Замыкания 
- это комбинация функции и лексическое окружение в котором функция была определена
- создается каждый раз при создании функции

#### Стиль передачи продолжений Continuation-Passing Style, CPS
- обратный вызов функции, переданную в аргументе другой функции вызываемой после завершения операции
- function add(a, b, callback){ callback(a + b) }

#### Обратный вызов не связанный со стилем передачи продолжений. Прямой стиль
- перебор map - синхронный!!! 
```
  const result = [1, 5, 7].map(el => el - 1)
  console.log(res) // [0, 5, 6]
```
- > Важно определять Синхронный или Асинхронный программный интерфейс

* Для прямого стиля (синхронного) нет смысла использовать вызовы с продолжением

- > Используйте прямой стиль при создании синхронных функций
- > Синхронный стиль блокирует приложение. Ломает модель параллельной обработки JavaScript
- > Использование синхронного ввода/вывода не рекомендовано во многих случаях. Только при нескольких 
статических файлах.
- > Для чтения конфигурационных файлов при загрузке ОБЯЗАТЕЛЬНО Синхронный стиль 
```
  const cache = {}

    function consistentReadSync(filename){
        if(cache[filename]){
            return cache[filename]
        } else {
            cache[filename] = fs.readFileSync(filename, 'utf8') // Синхронная
            return cache[filename]
        }
    }
```

### Перевод синхронного операции в асинхронную
- добавить отложенный вызов в 'process.nextTick' - process.nextTick(()=> callback(cache[filename]))
- отложенные обратные вызовы методом nextTick, выполняются доя любых событий ввода/вывода
- При этом, 'setImmediate' помещает в очередь за уже находящимися в очереди событиями ввода/вывода

### Соглашения об обратных вызовах при использовании CPS
- callback передается последним в списке параметров (последний аргумент), даже при наличии необязательных параметрах
  - fs.readFile(filename, [options], callback)
- ошибки передаются первыми
  - стараться всегда передавать ошибку типа Error, а не строку
  - для прерывания операции можно возвращать обратный вызов, чтобы предотвратить дальнейшее выполнение метода
  - fs.readFile('foo.txt.', 'utf8', (err, data)=> if(err) {return callback(err)} else {callback(null, data)}
  
### Ошибки и исключения
- в Синхронном стиле ошибки передаются throw
- в Асинхронном стиле ошибка передается через обратный вызов в  цепочке
- Исключение перехваченное внутри асинхронного обратного вызова, будет передано циклу событий и никогда не достигнет обратного вызова
  - поэтому в асинхронном стиле используем try catch и передаем ошибке в обратный вызов, а не throw

ЗАКОНЧИЛ на 50 странице